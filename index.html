<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>File Combiner & Splitter Pro</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* Custom Scrollbar */
        .scrollbar-thin { scrollbar-width: thin; scrollbar-color: #4a5568 #374151; }
        .scrollbar-thin::-webkit-scrollbar { width: 8px; }
        .scrollbar-thin::-webkit-scrollbar-track { background: #374151; border-radius: 4px; }
        .scrollbar-thin::-webkit-scrollbar-thumb { background-color: #4a5568; border-radius: 4px; border: 2px solid #374151; }
        .scrollbar-thin::-webkit-scrollbar-thumb:hover { background-color: #718096; }

        /* Spinner Animation */
        .spinner { border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top-color: #fff; width: 16px; height: 16px; animation: spin 1s linear infinite; display: inline-block; vertical-align: middle; margin-right: 8px; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Focus Styles */
        *:focus { outline: none; }
        *:focus-visible { outline: 2px solid #63b3ed; outline-offset: 2px; }
        input:focus-visible, select:focus-visible, button:focus-visible, textarea:focus-visible { box-shadow: 0 0 0 2px rgba(99, 179, 237, 0.5); }

        /* Minor style for checkbox alignment */
        .checkbox-label { display: flex; align-items: center; }

        /* Mode Switcher Styles */
        .mode-btn { transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out; }
        .mode-btn.active { background-color: #4A5568; /* gray-700 */ color: #F7FAFC; /* gray-100 */ }
        .mode-btn:not(.active) { background-color: #2D3748; /* gray-800 */ color: #A0AEC0; /* gray-500 */ }
        
        /* NEW: Drag and Drop Styles */
        #mainContainer.drag-over { border: 2px dashed #63b3ed; background-color: #374151; }
        #fileListContainer .dragging { opacity: 0.5; background-color: #4c5a70; }

        /* NEW: Modal Styles */
        .modal-backdrop { background-color: rgba(0, 0, 0, 0.7); }
        .modal-content { max-height: 80vh; }
    
        /* Theme Variables */
        :root {
            --bg-primary: #1f2937;
            --bg-secondary: #111827;
            --bg-tertiary: #374151;
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --text-tertiary: #9ca3af;
            --border-color: #4b5563;
            --accent-color: #3b82f6;
            --accent-hover: #2563eb;
            --success-color: #10b981;
            --error-color: #ef4444;
            --scrollbar-track: #374151;
            --scrollbar-thumb: #4a5568;
            --scrollbar-thumb-hover: #718096;
        }

        [data-theme="light"] {
            --bg-primary: #f3f4f6;
            --bg-secondary: #ffffff;
            --bg-tertiary: #e5e7eb;
            --text-primary: #111827;
            --text-secondary: #374151;
            --text-tertiary: #6b7280;
            --border-color: #d1d5db;
            --accent-color: #3b82f6;
            --accent-hover: #2563eb;
            --success-color: #059669;
            --error-color: #dc2626;
            --scrollbar-track: #e5e7eb;
            --scrollbar-thumb: #9ca3af;
            --scrollbar-thumb-hover: #6b7280;
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s, color 0.3s;
            overflow-x: hidden;
        }

        .scrollbar-thin { 
            scrollbar-width: thin; 
            scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track); 
        }
        .scrollbar-thin::-webkit-scrollbar { width: 8px; }
        .scrollbar-thin::-webkit-scrollbar-track { 
            background: var(--scrollbar-track); 
            border-radius: 4px; 
        }
        .scrollbar-thin::-webkit-scrollbar-thumb { 
            background-color: var(--scrollbar-thumb); 
            border-radius: 4px; 
            border: 2px solid var(--scrollbar-track); 
        }
        .scrollbar-thin::-webkit-scrollbar-thumb:hover { 
            background-color: var(--scrollbar-thumb-hover); 
        }

        .theme-toggle {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 1000;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 2.5rem;
            height: 2.5rem;
        }

        .theme-toggle:hover {
            background-color: var(--accent-color);
            transform: scale(1.05);
        }

        .bg-gray-900 { background-color: var(--bg-secondary) !important; }
        .bg-gray-800 { background-color: var(--bg-primary) !important; }
        .bg-gray-700 { background-color: var(--bg-tertiary) !important; }
        .text-white { color: var(--text-primary) !important; }
        .text-gray-300 { color: var(--text-secondary) !important; }
        .text-gray-400 { color: var(--text-tertiary) !important; }
        .border-gray-600 { border-color: var(--border-color) !important; }

        /* Mobile-First Responsive Design */
        .container {
            padding: 0.75rem;
            max-width: 100%;
        }

        h1 {
            font-size: 1.5rem;
            line-height: 2rem;
        }

        h2 {
            font-size: 1.25rem;
            line-height: 1.75rem;
        }

        button, .btn {
            min-height: 44px;
            padding: 0.625rem 1rem;
            font-size: 0.875rem;
        }

        input, select, textarea {
            min-height: 44px;
            font-size: 16px;
        }

        .file-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
        }

        textarea {
            min-height: 200px;
        }

        @media (min-width: 640px) {
            .container {
                padding: 1.5rem;
            }

            h1 {
                font-size: 2rem;
                line-height: 2.5rem;
            }

            h2 {
                font-size: 1.5rem;
                line-height: 2rem;
            }

            button, .btn {
                font-size: 1rem;
            }

            textarea {
                min-height: 300px;
            }
        }

        @media (min-width: 768px) {
            .container {
                padding: 2rem;
            }

            h1 {
                font-size: 2.25rem;
                line-height: 2.75rem;
            }
        }

        @media (min-width: 1024px) {
            .container {
                max-width: 1024px;
                margin: 0 auto;
            }
        }

        @media (min-width: 1280px) {
            .container {
                max-width: 1280px;
            }
        }

        @media (max-width: 639px) {
            .theme-toggle {
                top: 0.5rem;
                right: 0.5rem;
                width: 2.25rem;
                height: 2.25rem;
            }

            .button-group {
                flex-direction: column;
                gap: 0.5rem;
            }

            .button-group button {
                width: 100%;
            }

            .modal-content {
                width: 95vw !important;
                max-height: 90vh;
                margin: 5vh 2.5vw;
            }

            .file-list-container {
                max-height: 40vh;
            }

            table {
                font-size: 0.875rem;
            }

            .config-item {
                margin-bottom: 1rem;
            }

            body.is-mobile {
                padding-top: 3.5rem;
            }
        }

        @media (max-width: 768px) and (orientation: landscape) {
            .file-list-container {
                max-height: 30vh;
            }

            .modal-content {
                max-height: 85vh;
            }
        }

        @media (hover: none) and (pointer: coarse) {
            a, button, input, select, textarea {
                min-height: 44px;
                min-width: 44px;
            }

            button:hover {
                transform: none;
            }

            .modal-close {
                padding: 1rem;
            }
        }

        .mobile-vh-100 {
            height: 100vh;
            height: calc(var(--vh, 1vh) * 100);
        }

        .modal {
            max-height: 100vh;
            max-height: calc(var(--vh, 1vh) * 100);
        }
</style>
</head>
<body class="min-h-screen bg-gray-900 flex flex-col items-center pt-6 px-4 text-gray-200 font-sans">
    <!-- Theme Toggle Button -->
    <button id="themeToggle" class="theme-toggle" title="Toggle Theme" aria-label="Toggle Theme">
        <svg id="sunIcon" class="w-5 h-5 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                  d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z">
            </path>
        </svg>
        <svg id="moonIcon" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                  d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z">
            </path>
        </svg>
    </button>



<!-- Main Container -->
<div id="mainContainer" class="w-full max-w-lg bg-gray-800 rounded-lg shadow-xl p-3 sm:p-6 mb-4 sm:mb-6 transition-colors duration-200">
    <h1 class="text-xl sm:text-2xl font-semibold text-center text-white mb-4">File Combiner & Splitter Pro</h1>

    <!-- Mode Switcher -->
    <div class="flex justify-center mb-5 border border-gray-600 rounded-md p-1 bg-gray-800">
        <button id="modeCombineButton" class="mode-btn w-1/2 py-2 px-4 rounded-md text-sm font-medium">Combine</button>
        <button id="modeSplitButton" class="mode-btn w-1/2 py-2 px-4 rounded-md text-sm font-medium">Split</button>
    </div>

    <!-- ===== COMBINE MODE SECTION ===== -->
    <div id="combineSection">
        <!-- Structure & Comment Options (Combined into a details/summary for cleaner UI) -->
        <details class="mb-5 border border-gray-700 rounded-md p-3 bg-gray-800/30">
            <summary class="cursor-pointer text-base font-medium text-gray-100">Options & Configuration</summary>
            <div class="mt-4 space-y-4">
                <div>
                    <label for="structureFormat" class="text-white text-sm font-medium mb-2 block">Structure Format:</label>
                    <select id="structureFormat" class="w-full bg-gray-700 text-white rounded p-2 border border-gray-600">
                        <option value="tree">Tree</option><option value="flat">Flat List</option><option value="simple">Numbered List</option><option value="detailed">Detailed Summary</option><option value="markdown">Markdown List</option><option value="none">None</option>
                    </select>
                </div>
                 <div class="mb-3">
                    <label for="disableCommentsCheckbox" class="checkbox-label text-sm text-gray-300 cursor-pointer">
                        <input type="checkbox" id="disableCommentsCheckbox" class="mr-2 h-4 w-4 rounded border-gray-500 bg-gray-700 text-blue-500 focus:ring-blue-500 focus:ring-offset-gray-800">
                        Disable Start/End Comments
                    </label>
                </div>
                <div>
                    <label for="startComment" class="text-white text-sm font-medium mb-1 block">Start Comment Template:</label>
                    <input type="text" id="startComment" class="w-full p-2 bg-gray-700 text-white rounded border border-gray-600 text-sm" value="/* ==== START {index}/{totalFiles} - {filename} ({path}) ==== */">
                </div>
                <div>
                    <label for="endComment" class="text-white text-sm font-medium mb-1 block">End Comment Template:</label>
                    <input type="text" id="endComment" class="w-full p-2 bg-gray-700 text-white rounded border border-gray-600 text-sm" value="/* ==== END - {filename} ==== */">
                </div>
                <!-- NEW: Exclusion Filter -->
                <div>
                    <label for="exclusionFilter" class="text-white text-sm font-medium mb-1 block">Exclusion Filter (gitignore style):</label>
                    <textarea id="exclusionFilter" rows="3" class="w-full p-2 bg-gray-700 text-white rounded border border-gray-600 text-sm font-mono scrollbar-thin" placeholder="e.g., node_modules/
*.log
dist/"></textarea>
                </div>
                <!-- NEW: Save/Load Config -->
                <div class="flex items-center space-x-2 pt-2">
                    <button id="saveConfigButton" class="px-3 py-1.5 text-xs bg-gray-600 hover:bg-gray-500 rounded font-medium">Save Config</button>
                    <button id="loadConfigButton" class="px-3 py-1.5 text-xs bg-gray-600 hover:bg-gray-500 rounded font-medium">Load Config</button>
                    <span id="configStatus" class="text-xs text-green-400"></span>
                </div>
            </div>
        </details>

        <!-- File Input -->
        <div class="mb-4 text-center">
            <input type="file" id="fileInput" multiple webkitdirectory directory onchange="handleFileInputChange()" class="hidden" />
            <label for="fileInput" class="w-full inline-block px-5 py-3 bg-blue-600 text-white rounded shadow-md hover:bg-blue-700 active:bg-blue-800 transition-all cursor-pointer font-medium">
                Add Files / Folder / Zip
            </label>
            <p class="text-xs text-gray-400 mt-2">You can also drag and drop files or folders here.</p>
            <div id="processingIndicator" class="hidden text-sm text-gray-400 mt-3 text-center">
                <span class="spinner"></span> <span id="processingText">Processing...</span>
            </div>
        </div>
        
        <!-- NEW: File Search -->
        <div class="mb-2">
            <input type="search" id="fileSearch" placeholder="Filter selected files..." class="w-full p-2 bg-gray-700 text-white rounded border border-gray-600 text-sm" autocomplete="off">
        </div>

        <!-- File List & Actions -->
        <div class="mb-4">
            <div class="flex justify-between items-center mb-2">
                <label class="text-white text-sm font-medium">Selected Files (Drag to reorder):</label>
                <div>
                    <!-- NEW: Show Stats Button -->
                    <button id="statsButton" class="px-2 py-1 text-xs bg-teal-600 hover:bg-teal-700 rounded shadow-sm font-medium mr-2 disabled:opacity-50 disabled:cursor-not-allowed" disabled>Stats</button>
                    <button id="clearAllButton" class="px-2 py-1 text-xs bg-red-600 hover:bg-red-700 rounded shadow-sm font-medium disabled:opacity-50 disabled:cursor-not-allowed" disabled>Clear All</button>
                </div>
            </div>
            <div id="fileListContainer" class="max-h-60 overflow-y-auto scrollbar-thin border border-gray-600 rounded-lg p-3 text-sm text-gray-300 bg-gray-700 min-h-[60px]">
                <p id="noFilesMessage" class="text-gray-400 italic text-center py-2">No files selected yet.</p>
            </div>
        </div>

        <!-- Combine Button -->
        <button id="combineButton" class="w-full px-5 py-3 bg-green-600 text-white rounded shadow-md hover:bg-green-700 active:bg-green-800 transition-all disabled:opacity-50 disabled:cursor-not-allowed font-semibold mb-4" disabled>
            Combine <span id="fileCount">(0)</span> Files
        </button>

        <!-- Download & Copy Area -->
        <div id="outputArea" class="mt-2 text-center hidden space-y-2 sm:space-y-0 sm:space-x-2 sm:flex sm:justify-center">
            <a id="downloadLink" class="inline-block w-full sm:w-auto px-4 py-2 bg-purple-600 text-white rounded shadow-md hover:bg-purple-700 active:bg-purple-800 transition-all text-sm font-medium truncate max-w-full" download="combined_files.txt"></a>
            <button id="copyButton" onclick="copyToClipboard()" class="inline-block w-full sm:w-auto px-4 py-2 bg-indigo-600 text-white rounded shadow-md hover:bg-indigo-700 active:bg-indigo-800 transition-all text-sm font-medium">
                Copy to Clipboard
            </button>
        </div>
        <p id="copyStatusMessage" class="text-center text-green-400 text-xs mt-2 h-3"></p>
    </div>

    <!-- ===== SPLIT MODE SECTION ===== -->
    <div id="splitSection" class="hidden">
        <p class="text-sm text-center text-gray-400 mb-4">Select a `.txt` file created by this tool to split it back into its original files.</p>
        <div class="mb-4 text-center">
            <input type="file" id="splitFileInput" accept=".txt" onchange="updateSplitUI()" class="hidden" />
            <label for="splitFileInput" class="w-full inline-block px-5 py-3 bg-blue-600 text-white rounded shadow-md hover:bg-blue-700 active:bg-blue-800 cursor-pointer font-medium">Select .txt File</label>
        </div>
        <div id="splitFileInfo" class="text-center text-sm text-gray-300 mb-4 h-5"></div>
        <button id="splitButton" onclick="splitAndZip()" class="w-full px-5 py-3 bg-green-600 text-white rounded shadow-md hover:bg-green-700 active:bg-green-800 disabled:opacity-50 disabled:cursor-not-allowed font-semibold mb-4" disabled>Split & Create Zip</button>
         <div id="splitOutputArea" class="mt-2 text-center hidden">
             <a id="splitDownloadLink" class="inline-block w-full sm:w-auto px-4 py-2 bg-purple-600 text-white rounded shadow-md hover:bg-purple-700 active:bg-purple-800 text-sm font-medium truncate max-w-full"></a>
         </div>
         <p class="text-xs text-gray-500 text-center mt-3">Note: Splitting works best with files containing a manifest, but will fall back to parsing comments.</p>
    </div>
    
    <!-- Shared Error Message Area -->
    <p id="errorMessage" class="text-red-400 text-sm mt-2 text-center h-4"></p>
</div>

<!-- NEW: Statistics Modal -->
<div id="statsModal" class="fixed inset-0 z-50 flex items-center justify-center p-4 hidden">
    <div id="statsModalBackdrop" class="modal-backdrop fixed inset-0"></div>
    <div class="modal-content relative w-full max-w-2xl bg-gray-800 rounded-lg shadow-xl p-3 sm:p-6 text-gray-200 overflow-y-auto scrollbar-thin">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-semibold">Content Statistics</h2>
            <button id="closeStatsModal" class="text-gray-400 hover:text-white">×</button>
        </div>
        <div id="statsContent" class="space-y-4">
            <!-- Stats will be rendered here by JS -->
        </div>
    </div>
</div>

<!-- JSZip Script Loading -->
<script>
    const JSZIP_SOURCES = ['https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js','https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js','jszip.min.js'];
    let jszipLoadingPromise = null;
    let jszipLoaded = (typeof JSZip !== 'undefined');
    async function loadJSZipIfNeeded() { if (jszipLoaded) return true; if (jszipLoadingPromise) return jszipLoadingPromise; console.log("Attempting to load JSZip..."); jszipLoadingPromise = new Promise((resolve, reject) => { let attempts = 0; const maxAttempts = JSZIP_SOURCES.length; function tryLoad() { if (attempts >= maxAttempts) { console.error('Failed to load JSZip after trying all sources.'); jszipLoadingPromise = null; return reject(new Error('Failed to load JSZip library. Cannot process Zip files.')); } const source = JSZIP_SOURCES[attempts++]; const script = document.createElement('script'); script.src = source; script.async = true; const timeoutId = setTimeout(() => { script.remove(); tryLoad(); }, 5000); script.onload = () => { clearTimeout(timeoutId); if (typeof JSZip !== 'undefined') { console.log(`JSZip loaded successfully from ${source}`); jszipLoaded = true; jszipLoadingPromise = null; resolve(true); } else { script.remove(); tryLoad(); } }; script.onerror = () => { clearTimeout(timeoutId); script.remove(); tryLoad(); }; document.head.appendChild(script); } tryLoad(); }); return jszipLoadingPromise; }
</script>

<!-- Main Application Logic -->
<script>
// --- Globals and State Management ---
const dom = { // Gather all DOM element references in one place
    mainContainer: document.getElementById('mainContainer'),
    combineSection: document.getElementById('combineSection'),
    splitSection: document.getElementById('splitSection'),
    modeCombineButton: document.getElementById('modeCombineButton'),
    modeSplitButton: document.getElementById('modeSplitButton'),
    fileInput: document.getElementById('fileInput'),
    fileListContainer: document.getElementById('fileListContainer'),
    combineButton: document.getElementById('combineButton'),
    clearAllButton: document.getElementById('clearAllButton'),
    fileCountSpan: document.getElementById('fileCount'),
    outputArea: document.getElementById('outputArea'),
    downloadLink: document.getElementById('downloadLink'),
    copyButton: document.getElementById('copyButton'),
    copyStatusMessage: document.getElementById('copyStatusMessage'),
    processingIndicator: document.getElementById('processingIndicator'),
    processingText: document.getElementById('processingText'),
    errorMessage: document.getElementById('errorMessage'),
    splitFileInput: document.getElementById('splitFileInput'),
    splitFileInfo: document.getElementById('splitFileInfo'),
    splitButton: document.getElementById('splitButton'),
    splitOutputArea: document.getElementById('splitOutputArea'),
    splitDownloadLink: document.getElementById('splitDownloadLink'),
    // New Elements
    structureFormat: document.getElementById('structureFormat'),
    disableCommentsCheckbox: document.getElementById('disableCommentsCheckbox'),
    startComment: document.getElementById('startComment'),
    endComment: document.getElementById('endComment'),
    exclusionFilter: document.getElementById('exclusionFilter'),
    saveConfigButton: document.getElementById('saveConfigButton'),
    loadConfigButton: document.getElementById('loadConfigButton'),
    configStatus: document.getElementById('configStatus'),
    fileSearch: document.getElementById('fileSearch'),
    statsButton: document.getElementById('statsButton'),
    statsModal: document.getElementById('statsModal'),
    statsModalBackdrop: document.getElementById('statsModalBackdrop'),
    closeStatsModal: document.getElementById('closeStatsModal'),
    statsContent: document.getElementById('statsContent'),
};

let appState = {
    mode: 'combine',
    selectedFiles: [],
    nextFileId: 0,
    lastCombinedContent: '',
    draggedItemId: null,
};

const ALLOWED_EXTENSIONS = new Set(['txt', 'js', 'ts', 'jsx', 'tsx', 'css', 'html', 'htm', 'py', 'rb', 'java', 'c', 'cpp', 'h', 'hpp', 'cs', 'php', 'sql', 'md', 'json', 'xml', 'yaml', 'yml', 'sh', 'bat', 'ini', 'log', 'svg', 'gitignore', 'env', 'dockerfile', 'conf', 'config', 'gradle', 'properties', 'toml', 'rst']);

// --- Utility Functions ---
function displayError(msg, duration = 5000) { console.error(msg); dom.errorMessage.textContent = msg; if (duration > 0) setTimeout(() => dom.errorMessage.textContent = '', duration); }
function getFileExtension(filename) { return filename.slice((filename.lastIndexOf(".") - 1 >>> 0) + 2).toLowerCase(); }
function isLikelyTextFile(name, path) { const ext = getFileExtension(name); if (ALLOWED_EXTENSIONS.has(ext)) return true; if (/^\..*rc$/i.test(name) || /^\.?gitignore$/i.test(name) || name.toLowerCase() === 'dockerfile') return true; return false; }
function readFileAsText(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = (e) => reject(new Error(`Error reading ${file.name}: ${e.target.error}`)); reader.readAsText(file); }); }
function formatBytes(bytes, decimals = 2) { if (bytes === 0) return '0 Bytes'; const k = 1024; const dm = decimals < 0 ? 0 : decimals; const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i]; }

// --- Initialization ---
document.addEventListener('DOMContentLoaded', () => {
    initEventListeners();
    initDragAndDrop();
    loadConfig();
    setMode('combine');
    loadJSZipIfNeeded().catch(err => console.warn("Preloading JSZip failed:", err.message));
});


        // ========================================
        // Theme Management
        // ========================================
        function initTheme() {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeIcon(savedTheme);
        }

        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            updateThemeIcon(newTheme);
        }

        function updateThemeIcon(theme) {
            const sunIcon = document.getElementById('sunIcon');
            const moonIcon = document.getElementById('moonIcon');
            if (theme === 'light') {
                sunIcon.classList.add('hidden');
                moonIcon.classList.remove('hidden');
            } else {
                sunIcon.classList.remove('hidden');
                moonIcon.classList.add('hidden');
            }
        }

        // ========================================
        // Mobile-First Utilities
        // ========================================
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function isTouchDevice() {
            return ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        }

        function setMobileVH() {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        }

        function optimizeScrolling() {
            const scrollableElements = document.querySelectorAll('.scrollbar-thin');
            scrollableElements.forEach(el => {
                el.style.webkitOverflowScrolling = 'touch';
            });
        }

        function preventZoomOnFocus() {
            if (isMobileDevice()) {
                const inputs = document.querySelectorAll('input[type="text"], textarea, select');
                inputs.forEach(input => {
                    if (input.style.fontSize !== '16px') {
                        input.style.fontSize = '16px';
                    }
                });
            }
        }

        function handleOrientationChange() {
            setMobileVH();
            window.dispatchEvent(new Event('resize'));
        }

        function initMobileOptimizations() {
            if (isMobileDevice() || isTouchDevice()) {
                setMobileVH();
                optimizeScrolling();
                preventZoomOnFocus();

                window.addEventListener('resize', setMobileVH);
                window.addEventListener('orientationchange', handleOrientationChange);

                document.body.classList.add('is-mobile');
            }
        }


        function initEventListeners() {
        document.getElementById('themeToggle').addEventListener('click', toggleTheme);

    dom.modeCombineButton.addEventListener('click', () => setMode('combine'));
    dom.modeSplitButton.addEventListener('click', () => setMode('split'));
    dom.clearAllButton.addEventListener('click', clearAllFiles);
    dom.combineButton.addEventListener('click', combineFiles);
    dom.fileSearch.addEventListener('input', filterFileList);
    dom.saveConfigButton.addEventListener('click', saveConfig);
    dom.loadConfigButton.addEventListener('click', loadConfig);
    dom.statsButton.addEventListener('click', showStatsModal);
    dom.closeStatsModal.addEventListener('click', hideStatsModal);
    dom.statsModalBackdrop.addEventListener('click', hideStatsModal);
}

// --- Mode Switching ---
function setMode(newMode) {
    if (newMode === appState.mode) return;
    appState.mode = newMode;
    dom.errorMessage.textContent = '';

    const isCombine = appState.mode === 'combine';
    dom.combineSection.classList.toggle('hidden', !isCombine);
    dom.splitSection.classList.toggle('hidden', isCombine);
    dom.modeCombineButton.classList.toggle('active', isCombine);
    dom.modeSplitButton.classList.toggle('active', !isCombine);

    if (isCombine) {
        dom.splitFileInput.value = '';
        updateSplitUI();
    } else {
        clearAllFiles();
    }
}

// --- Configuration Management (NEW) ---
function saveConfig() {
    const config = {
        structureFormat: dom.structureFormat.value,
        disableComments: dom.disableCommentsCheckbox.checked,
        startComment: dom.startComment.value,
        endComment: dom.endComment.value,
        exclusionFilter: dom.exclusionFilter.value,
    };
    localStorage.setItem('fileCombinerConfig', JSON.stringify(config));
    dom.configStatus.textContent = 'Saved!';
    setTimeout(() => dom.configStatus.textContent = '', 2000);
}

function loadConfig() {
    const savedConfig = localStorage.getItem('fileCombinerConfig');
    if (savedConfig) {
        const config = JSON.parse(savedConfig);
        dom.structureFormat.value = config.structureFormat || 'tree';
        dom.disableCommentsCheckbox.checked = config.disableComments || false;
        dom.startComment.value = config.startComment || '/* ==== START {index}/{totalFiles} - {filename} ({path}) ==== */';
        dom.endComment.value = config.endComment || '/* ==== END - {filename} ==== */';
        dom.exclusionFilter.value = config.exclusionFilter || '';
        dom.configStatus.textContent = 'Loaded!';
        setTimeout(() => dom.configStatus.textContent = '', 2000);
    }
}

// --- File Handling & Processing (HEAVILY REVISED) ---
function handleFileInputChange() {
    processFileSources(Array.from(dom.fileInput.files));
    dom.fileInput.value = ''; // Reset input
}

async function processFileSources(sources) {
    dom.processingIndicator.classList.remove('hidden');
    dom.processingText.textContent = 'Processing...';
    dom.errorMessage.textContent = '';
    
    let filesToAdd = [];
    const exclusionPatterns = dom.exclusionFilter.value.split('\n').map(p => p.trim()).filter(Boolean);

    for (const source of sources) {
        if (source.name.toLowerCase().endsWith('.zip')) {
            try {
                await loadJSZipIfNeeded();
                const zip = await JSZip.loadAsync(source);
                for (const [relativePath, entry] of Object.entries(zip.files)) {
                    if (!entry.dir && !isPathExcluded(relativePath, exclusionPatterns) && isLikelyTextFile(entry.name, relativePath)) {
                        const content = await entry.async('string');
                        filesToAdd.push({ id: appState.nextFileId++, displayName: relativePath, content: content, originalSize: content.length });
                    }
                }
            } catch (err) { displayError(`Error processing ${source.name}: ${err.message}`, 0); }
        } else if (!isPathExcluded(source.webkitRelativePath || source.name, exclusionPatterns) && isLikelyTextFile(source.name, source.webkitRelativePath)) {
             try {
                const content = await readFileAsText(source);
                filesToAdd.push({ id: appState.nextFileId++, displayName: source.webkitRelativePath || source.name, content: content, originalSize: source.size });
             } catch (err) { displayError(err.message, 0); }
        }
    }
    
    if (filesToAdd.length > 0) {
        appState.selectedFiles.push(...filesToAdd);
        appState.selectedFiles.sort((a, b) => a.displayName.localeCompare(b.displayName));
    } else if (sources.length > 0) {
        displayError('No new processable text files found.', 5000);
    }
    
    dom.processingIndicator.classList.add('hidden');
    updateUI();
}

function isPathExcluded(path, patterns) {
    if (patterns.length === 0) return false;

    // Simple glob to regex converter
    const patternToRegex = p => new RegExp('^' + p.replace(/\./g, '\\.').replace(/\*/g, '.*') + '$');
    
    for (const pattern of patterns) {
        if (pattern.endsWith('/')) { // Directory match
            if ((path + '/').startsWith(pattern)) return true;
        } else { // File match
            if (patternToRegex(pattern).test(path.split('/').pop())) return true; // Match filename
            if (patternToRegex(pattern).test(path)) return true; // Match full path
        }
    }
    return false;
}

function clearAllFiles() {
    appState.selectedFiles = [];
    dom.fileInput.value = '';
    updateUI();
    displayError('', 0);
}

function removeFile(id) {
    appState.selectedFiles = appState.selectedFiles.filter(f => f.id !== id);
    updateUI();
}

// --- UI Update Functions ---
function updateUI() {
    updateFileListUI();
    const count = appState.selectedFiles.length;
    dom.combineButton.disabled = count === 0;
    dom.clearAllButton.disabled = count === 0;
    dom.statsButton.disabled = count === 0;
    dom.fileCountSpan.textContent = `(${count})`;
    dom.outputArea.classList.add('hidden');
    appState.lastCombinedContent = '';
    dom.copyStatusMessage.textContent = '';
    if (dom.downloadLink.href) {
        URL.revokeObjectURL(dom.downloadLink.href);
        dom.downloadLink.removeAttribute('href');
        dom.downloadLink.textContent = '';
    }
}

function updateFileListUI() {
    dom.fileListContainer.innerHTML = '';
    if (appState.selectedFiles.length === 0) {
        const p = document.createElement('p');
        p.className = 'text-gray-400 italic text-center py-2';
        p.textContent = 'No files selected yet.';
        dom.fileListContainer.appendChild(p);
    } else {
        appState.selectedFiles.forEach(f => {
            const div = document.createElement('div');
            div.className = 'flex justify-between items-center bg-gray-600 px-3 py-1.5 rounded hover:bg-gray-500 transition-colors duration-150 ease-in-out cursor-grab';
            div.dataset.id = f.id;
            div.draggable = true;
            
            const displayNameSpan = document.createElement('span');
            displayNameSpan.className = 'truncate mr-2 flex-1 pointer-events-none';
            displayNameSpan.textContent = f.displayName;
            displayNameSpan.title = f.displayName;
            
            const removeButton = document.createElement('button');
            removeButton.onclick = (e) => { e.stopPropagation(); removeFile(f.id); };
            removeButton.className = 'ml-2 text-red-400 hover:text-red-300 px-1';
            removeButton.innerHTML = '×';
            removeButton.ariaLabel = `Remove ${f.displayName}`;
            
            div.appendChild(displayNameSpan);
            div.appendChild(removeButton);
            dom.fileListContainer.appendChild(div);
        });
    }
    filterFileList(); // Re-apply filter after updating list
}

function filterFileList() {
    const searchTerm = dom.fileSearch.value.toLowerCase();
    const items = dom.fileListContainer.querySelectorAll('[data-id]');
    items.forEach(item => {
        const text = item.textContent.toLowerCase();
        item.classList.toggle('hidden', !text.includes(searchTerm));
    });
}

// --- Drag and Drop (NEW) ---
function initDragAndDrop() {
    // For dropping files onto the window
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dom.mainContainer.addEventListener(eventName, e => {
            e.preventDefault();
            e.stopPropagation();
        }, false);
    });

    dom.mainContainer.addEventListener('dragenter', () => dom.mainContainer.classList.add('drag-over'));
    dom.mainContainer.addEventListener('dragleave', (e) => {
        if (e.relatedTarget === null || !dom.mainContainer.contains(e.relatedTarget)) {
            dom.mainContainer.classList.remove('drag-over');
        }
    });

    dom.mainContainer.addEventListener('drop', async (e) => {
        dom.mainContainer.classList.remove('drag-over');
        const items = e.dataTransfer.items;
        const files = [];
        const entryPromises = [];

        async function scanFiles(entry) {
            if (entry.isFile) {
                return new Promise(resolve => entry.file(file => { files.push(file); resolve(); }));
            } else if (entry.isDirectory) {
                let reader = entry.createReader();
                let entries = await new Promise(resolve => reader.readEntries(e => resolve(e)));
                await Promise.all(entries.map(scanFiles));
            }
        }

        for (const item of items) {
            const entry = item.webkitGetAsEntry();
            if (entry) {
                entryPromises.push(scanFiles(entry));
            } else { // Fallback for non-webkit browsers / individual files
                 files.push(item.getAsFile());
            }
        }
        await Promise.all(entryPromises);
        processFileSources(files);
    });

    // For reordering files in the list
    dom.fileListContainer.addEventListener('dragstart', e => {
        if (e.target.dataset.id) {
            appState.draggedItemId = parseInt(e.target.dataset.id, 10);
            e.target.classList.add('dragging');
        }
    });

    dom.fileListContainer.addEventListener('dragover', e => {
        e.preventDefault();
        const target = e.target.closest('[data-id]');
        if (target && parseInt(target.dataset.id, 10) !== appState.draggedItemId) {
            const rect = target.getBoundingClientRect();
            const nextSibling = (e.clientY > rect.top + rect.height / 2) ? target.nextSibling : target;
            const draggedEl = dom.fileListContainer.querySelector('.dragging');
            if (draggedEl) {
                 dom.fileListContainer.insertBefore(draggedEl, nextSibling);
            }
        }
    });

    dom.fileListContainer.addEventListener('drop', e => {
        e.preventDefault();
        const draggedEl = dom.fileListContainer.querySelector('.dragging');
        if (!draggedEl) return;
        draggedEl.classList.remove('dragging');

        const newOrderIds = Array.from(dom.fileListContainer.querySelectorAll('[data-id]')).map(el => parseInt(el.dataset.id, 10));
        appState.selectedFiles.sort((a, b) => newOrderIds.indexOf(a.id) - newOrderIds.indexOf(b.id));
        
        appState.draggedItemId = null;
        updateUI(); // Re-render to ensure data and view are in sync
    });

    dom.fileListContainer.addEventListener('dragend', e => {
        const draggedEl = dom.fileListContainer.querySelector('.dragging');
        if (draggedEl) draggedEl.classList.remove('dragging');
        appState.draggedItemId = null;
    });
}

// --- Combine Mode Logic (Revised with Manifest) ---
function combineFiles() {
    displayError('', 0);
    dom.copyStatusMessage.textContent = '';
    if (appState.selectedFiles.length === 0) {
        displayError("No files selected to combine.", 3000);
        return;
    }

    // 1. Create Manifest
    const manifest = appState.selectedFiles.map(f => ({ path: f.displayName, size: f.content.length }));
    const manifestString = JSON.stringify(manifest);
    let combinedContent = `/* FCS_MANIFEST_V1:${manifestString} */\n\n`;

    // 2. Generate Structure Header
    const structureFormat = dom.structureFormat.value;
    const disableComments = dom.disableCommentsCheckbox.checked;
    let header = '';
    if (!disableComments) {
        try {
            const structureGenerators = {
                'tree': generateTreeStructure, 'flat': generateFlatStructure,
                'simple': generateSimpleListStructure, 'detailed': generateDetailedStructure,
                'markdown': generateMarkdownStructure, 'none': () => ''
            };
            header = (structureGenerators[structureFormat] || (()=>''))(appState.selectedFiles);
        } catch (e) {
            displayError(`Error generating file structure: ${e.message}`, 0);
            return;
        }
    }
    combinedContent += header ? header + '\n' : '';

    // 3. Append File Contents
    const startTemplate = dom.startComment.value;
    const endTemplate = dom.endComment.value;
    const totalFiles = appState.selectedFiles.length;
    appState.selectedFiles.forEach((file, index) => {
        const fileIndex = index + 1;
        const path = file.displayName;
        const filename = path.split('/').pop();
        if (!disableComments) {
            const startComment = startTemplate.replace(/\{filename\}/g, filename).replace(/\{path\}/g, path).replace(/\{index\}/g, fileIndex).replace(/\{totalFiles\}/g, totalFiles);
            combinedContent += startComment + '\n';
        }
        combinedContent += file.content + '\n'; // Always add content
        if (!disableComments) {
            const endComment = endTemplate.replace(/\{filename\}/g, filename).replace(/\{path\}/g, path).replace(/\{index\}/g, fileIndex).replace(/\{totalFiles\}/g, totalFiles);
            combinedContent += endComment + '\n\n';
        } else {
            combinedContent += '\n'; // Add separator even if comments are off
        }
    });

    appState.lastCombinedContent = combinedContent.trimEnd() + '\n';

    // 4. Create Download Link
    const dateStamp = new Date().toISOString().split('T')[0];
    const downloadFilename = `combined_files_${dateStamp}.txt`;
    try {
        const blob = new Blob([appState.lastCombinedContent], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        if (dom.downloadLink.href) URL.revokeObjectURL(dom.downloadLink.href);
        dom.downloadLink.href = url;
        dom.downloadLink.download = downloadFilename;
        dom.downloadLink.textContent = `Download ${downloadFilename}`;
        dom.outputArea.classList.remove('hidden');
    } catch (e) {
        displayError(`Error creating download file: ${e.message}`, 0);
    }
}

// Structure Generation Functions
function buildFileTree(files) { const tree = {}; files.forEach(f => { const segments = f.displayName.split('/').filter(Boolean); let currentLevel = tree; segments.forEach((segment, index) => { if (index === segments.length - 1) { if (!currentLevel.files) currentLevel.files = []; currentLevel.files.push(segment); } else { if (!currentLevel[segment]) currentLevel[segment] = { files: [] }; currentLevel = currentLevel[segment]; } }); }); return tree; }
function renderTree(node, depth = 0) { let output = ''; const indent = '  '.repeat(depth); Object.keys(node).sort().forEach(key => { if (key !== 'files') { output += `${indent}└─ ${key}/\n`; output += renderTree(node[key], depth + 1); } }); if (node.files) { node.files.sort().forEach(file => { output += `${indent}└─ ${file}\n`; }); } return output; }
function generateTreeStructure(files) { return `/* ==== File Structure (Tree) ====\n${renderTree(buildFileTree(files))}=============================== */\n`; }
function generateFlatStructure(files) { return `/* ==== File List (Flat) ====\n${files.map(f => f.displayName).sort().join('\n')}\n========================== */\n`; }
function generateSimpleListStructure(files) { return `/* ==== File List (Numbered) ====\n${files.map(f => f.displayName).sort().map((path, i) => `${i + 1}. ${path}`).join('\n')}\n============================ */\n`; }
function generateDetailedStructure(files) { const totalBytes = files.reduce((sum, f) => sum + (f.originalSize || 0), 0); const fileLines = files.map(f => `- ${f.displayName} (${formatBytes(f.originalSize || 0)})`).sort(); return `/* ==== Detailed Summary ====\nDate: ${new Date().toISOString()}\nTotal Files: ${files.length}\nTotal Size: ${formatBytes(totalBytes)}\n\nFiles:\n${fileLines.join('\n')}\n*/\n`; }
function generateMarkdownStructure(files) { let md = "# File Structure\n\n"; files.map(f => f.displayName).sort().forEach(path => md += `- \`${path}\`\n`); return md + '\n'; }

async function copyToClipboard() {
    dom.copyStatusMessage.textContent = '';
    if (!appState.lastCombinedContent) { displayError("No content to copy.", 3000); return; }
    try {
        await navigator.clipboard.writeText(appState.lastCombinedContent);
        dom.copyStatusMessage.textContent = 'Copied to clipboard!';
        setTimeout(() => { dom.copyStatusMessage.textContent = ''; }, 3000);
    } catch (err) {
        displayError(`Failed to copy: ${err}`, 5000);
    }
}

// --- Split Mode Logic (Revised with Manifest) ---
function updateSplitUI() {
    displayError('', 0);
    dom.splitOutputArea.classList.add('hidden');
    if (dom.splitDownloadLink.href) URL.revokeObjectURL(dom.splitDownloadLink.href);
    const file = dom.splitFileInput.files[0];
    dom.splitFileInfo.textContent = file ? file.name : '';
    dom.splitButton.disabled = !file;
}

async function splitAndZip() {
    const file = dom.splitFileInput.files[0];
    if (!file) { displayError("Please select a file.", 3000); return; }

    dom.splitButton.disabled = true;
    dom.splitButton.innerHTML = '<span class="spinner"></span>Processing...';
    displayError('', 0);

    try {
        await loadJSZipIfNeeded();
        const text = await readFileAsText(file);
        const zip = new JSZip();

        // Method 1: Try to find manifest (preferred)
        const manifestMatch = text.match(/\/\*\s*FCS_MANIFEST_V1:(\[.*?\])\s*\*\//);
        if (manifestMatch && manifestMatch[1]) {
            console.log("Splitting using manifest.");
            const manifest = JSON.parse(manifestMatch[1]);
            const contentStartIndex = manifestMatch.index + manifestMatch[0].length;
            
            // Find start of actual content, skipping headers
            let textCursor = text.substring(contentStartIndex);
            const firstStartCommentMatch = textCursor.match(/\/\*\s*====\s*START/);
            
            if (firstStartCommentMatch) {
                textCursor = textCursor.substring(firstStartCommentMatch.index);
            } else {
                 // No comments, assume content starts after a double newline
                const startOfContent = text.indexOf('\n\n', contentStartIndex) + 2;
                if(startOfContent > 1) {
                    textCursor = text.substring(startOfContent);
                } else { // Fallback if no double newline
                    textCursor = text.substring(contentStartIndex).trim();
                }
            }

            for (const fileEntry of manifest) {
                const fileContent = textCursor.substring(0, fileEntry.size);
                zip.file(fileEntry.path, fileContent);
                
                // Advance cursor past this file's content and its surrounding comments/newlines
                let chunkToEnd = textCursor.substring(fileEntry.size);
                const nextStartCommentMatch = chunkToEnd.match(/\/\*\s*====\s*START/);
                
                if (nextStartCommentMatch) {
                    textCursor = chunkToEnd.substring(nextStartCommentMatch.index);
                } else {
                    // This was the last file
                }
            }
        } else {
            // Method 2: Fallback to comment parsing
            console.log("Manifest not found. Splitting using comment parsing (fallback).");
            const startCommentRegex = /\/\*\s*====\s*START\s*\d+\/\d+\s*-\s*(.*?)\s*\((.*?)\)\s*====\s*\*\//g;
            const matches = [...text.matchAll(startCommentRegex)];
            if (matches.length === 0) throw new Error("Invalid format. No file start comments found.");

            for (let i = 0; i < matches.length; i++) {
                const match = matches[i];
                const nextMatch = matches[i + 1];
                const path = match[2].trim();
                if (!path) continue;

                const contentStartIndex = match.index + match[0].length;
                const contentEndIndex = nextMatch ? nextMatch.index : text.length;
                let content = text.substring(contentStartIndex, contentEndIndex);
                content = content.replace(/\/\*\s*====\s*END\s*-\s*.*?\s*====\s*\*\//, '').trim();
                zip.file(path, content);
            }
        }
        
        const zipBlob = await zip.generateAsync({ type: "blob", compression: "DEFLATE" });
        const url = URL.createObjectURL(zipBlob);
        const downloadFilename = `${file.name.replace(/\.txt$/i, '')}_split.zip`;
        
        if (dom.splitDownloadLink.href) URL.revokeObjectURL(dom.splitDownloadLink.href);
        dom.splitDownloadLink.href = url;
        dom.splitDownloadLink.download = downloadFilename;
        dom.splitDownloadLink.textContent = `Download ${downloadFilename}`;
        dom.splitOutputArea.classList.remove('hidden');

    } catch (err) {
        displayError(`Error splitting file: ${err.message}`, 0);
    } finally {
        dom.splitButton.disabled = false;
        dom.splitButton.innerHTML = 'Split & Create Zip';
    }
}

// --- Statistics Modal (NEW) ---
function showStatsModal() {
    if (appState.selectedFiles.length === 0) return;
    
    const totals = { files: 0, size: 0, lines: 0, chars: 0 };
    const byExtension = {};

    appState.selectedFiles.forEach(file => {
        const ext = getFileExtension(file.displayName) || 'other';
        const lines = file.content.split('\n').length;
        const chars = file.content.length;
        
        totals.files++;
        totals.size += file.originalSize;
        totals.lines += lines;
        totals.chars += chars;

        if (!byExtension[ext]) byExtension[ext] = { files: 0, size: 0, lines: 0, chars: 0 };
        byExtension[ext].files++;
        byExtension[ext].size += file.originalSize;
        byExtension[ext].lines += lines;
        byExtension[ext].chars += chars;
    });

    let html = `
        <div class="bg-gray-700 p-4 rounded-lg">
            <h3 class="font-semibold text-lg mb-2">Overall Totals</h3>
            <div class="grid grid-cols-2 sm:grid-cols-4 gap-2 sm:gap-4 text-center">
                <div><div class="text-xl sm:text-2xl font-bold">${totals.files.toLocaleString()}</div><div class="text-xs text-gray-400">Files</div></div>
                <div><div class="text-xl sm:text-2xl font-bold">${formatBytes(totals.size)}</div><div class="text-xs text-gray-400">Size</div></div>
                <div><div class="text-xl sm:text-2xl font-bold">${totals.lines.toLocaleString()}</div><div class="text-xs text-gray-400">Lines</div></div>
                <div><div class="text-xl sm:text-2xl font-bold">${totals.chars.toLocaleString()}</div><div class="text-xs text-gray-400">Characters</div></div>
            </div>
        </div>
        <div>
            <h3 class="font-semibold text-lg mb-2">By File Type</h3>
            <table class="w-full text-sm text-left">
                <thead class="text-xs text-gray-400 uppercase bg-gray-700/50">
                    <tr>
                        <th class="px-4 py-2">Extension</th>
                        <th class="px-4 py-2 text-right">Files</th>
                        <th class="px-4 py-2 text-right">Size</th>
                        <th class="px-4 py-2 text-right">Lines</th>
                    </tr>
                </thead>
                <tbody>
    `;

    Object.entries(byExtension).sort((a,b) => b[1].files - a[1].files).forEach(([ext, data]) => {
        html += `
            <tr class="border-b border-gray-700">
                <td class="px-4 py-2 font-medium">.${ext}</td>
                <td class="px-4 py-2 text-right">${data.files.toLocaleString()}</td>
                <td class="px-4 py-2 text-right">${formatBytes(data.size)}</td>
                <td class="px-4 py-2 text-right">${data.lines.toLocaleString()}</td>
            </tr>
        `;
    });

    html += `</tbody></table></div>`;
    dom.statsContent.innerHTML = html;
    dom.statsModal.classList.remove('hidden');
}

function hideStatsModal() {
    dom.statsModal.classList.add('hidden');
}

</script>

</body>
</html>
