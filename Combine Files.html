<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dark Mode File Combiner</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* Custom Scrollbar */
        .scrollbar-thin { scrollbar-width: thin; scrollbar-color: #4a5568 #374151; }
        .scrollbar-thin::-webkit-scrollbar { width: 8px; }
        .scrollbar-thin::-webkit-scrollbar-track { background: #374151; border-radius: 4px; }
        .scrollbar-thin::-webkit-scrollbar-thumb { background-color: #4a5568; border-radius: 4px; border: 2px solid #374151; }
        .scrollbar-thin::-webkit-scrollbar-thumb:hover { background-color: #718096; }

        /* Spinner Animation */
        .spinner { border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top-color: #fff; width: 16px; height: 16px; animation: spin 1s linear infinite; display: inline-block; vertical-align: middle; margin-right: 8px; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Focus Styles */
        *:focus { outline: none; }
        *:focus-visible { outline: 2px solid #63b3ed; outline-offset: 2px; }
        input:focus-visible, select:focus-visible, button:focus-visible { box-shadow: 0 0 0 2px rgba(99, 179, 237, 0.5); }

        /* Minor style for checkbox alignment */
        .checkbox-label { display: flex; align-items: center; }
    </style>
</head>
<body class="min-h-screen bg-gray-900 flex flex-col items-center pt-6 px-4 text-gray-200 font-sans">

<!-- Main Container -->
<div class="w-full max-w-lg bg-gray-800 rounded-lg shadow-xl p-6 mb-6">
    <h1 class="text-2xl font-semibold text-center text-white mb-5">File Combiner</h1>

    <!-- Structure Format Selector -->
    <div class="mb-4">
        <label for="structureFormat" class="text-white text-sm font-medium mb-2 block">Structure Format:</label>
        <select id="structureFormat" class="w-full bg-gray-700 text-white rounded p-2 border border-gray-600 focus:border-blue-500 focus:ring focus:ring-blue-500 focus:ring-opacity-50 transition duration-150 ease-in-out">
            <option value="tree">Tree</option>
            <option value="flat">Flat List</option>
            <option value="simple">Numbered List</option>
            <option value="detailed">Detailed Summary</option>
            <option value="markdown">Markdown List</option>
            <option value="none">None</option>
        </select>
    </div>

    <!-- Comment Options -->
    <div class="mb-5 space-y-3 border border-gray-700 rounded-md p-3 bg-gray-800/30">
         <h3 class="text-base font-medium text-gray-100 mb-2">Comment Options</h3>
         <!-- Disable Comments Checkbox -->
        <div class="mb-3">
            <label for="disableCommentsCheckbox" class="checkbox-label text-sm text-gray-300 cursor-pointer">
                <input type="checkbox" id="disableCommentsCheckbox" class="mr-2 h-4 w-4 rounded border-gray-500 bg-gray-700 text-blue-500 focus:ring-blue-500 focus:ring-offset-gray-800">
                Disable Start/End Comments
            </label>
        </div>

        <!-- Comment Templates -->
        <div>
            <label for="startComment" class="text-white text-sm font-medium mb-1 block">Start Comment Template:</label>
            <input type="text" id="startComment" class="w-full p-2 bg-gray-700 text-white rounded border border-gray-600 focus:border-blue-500 focus:ring focus:ring-blue-500 focus:ring-opacity-50 transition duration-150 ease-in-out text-sm"
                   value="/* ==== START {index}/{totalFiles} - {filename} ({path}) ==== */">
             <p class="text-xs text-gray-400 mt-1">Placeholders: {filename}, {path}, {index}, {totalFiles}</p>
        </div>
        <div>
             <label for="endComment" class="text-white text-sm font-medium mb-1 block">End Comment Template:</label>
            <input type="text" id="endComment" class="w-full p-2 bg-gray-700 text-white rounded border border-gray-600 focus:border-blue-500 focus:ring focus:ring-blue-500 focus:ring-opacity-50 transition duration-150 ease-in-out text-sm"
                   value="/* ==== END - {filename} ==== */">
             <p class="text-xs text-gray-400 mt-1">Placeholders: {filename}, {path}, {index}, {totalFiles}</p>
        </div>
    </div>


    <!-- File Input -->
    <div class="mb-4 text-center">
        <input type="file" id="fileInput" multiple accept=".css,.js,.ts,.jsx,.tsx,.html,.htm,.txt,.py,.rb,.java,.c,.cpp,.h,.hpp,.cs,.php,.sql,.md,.json,.xml,.yaml,.yml,.sh,.bat,.ini,.log,.svg,.zip" onchange="addFiles()" class="hidden" />
        <label for="fileInput" class="w-full inline-block px-5 py-3 bg-blue-600 text-white rounded shadow-md hover:bg-blue-700 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-offset-gray-800 focus-visible:ring-blue-500 active:bg-blue-800 transition-all cursor-pointer font-medium">
            Add Files or Zip Archive
        </label>
        <div id="processingZipIndicator" class="hidden text-sm text-gray-400 mt-3 text-center">
            <span class="spinner"></span> Processing Zip... please wait.
        </div>
        <p id="errorMessage" class="text-red-400 text-sm mt-2 text-center h-4"></p>
    </div>

    <!-- File List & Clear Button -->
    <div class="mb-4">
        <div class="flex justify-between items-center mb-2">
            <label class="text-white text-sm font-medium">Selected Files:</label>
            <button id="clearAllButton" onclick="clearAllFiles()" class="px-2 py-1 text-xs bg-red-600 text-white rounded shadow-sm hover:bg-red-700 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-offset-gray-800 focus-visible:ring-red-500 active:bg-red-800 transition-all disabled:opacity-50 disabled:cursor-not-allowed font-medium" disabled>
                Clear All
            </button>
        </div>
        <div id="fileListContainer" class="max-h-60 overflow-y-auto scrollbar-thin border border-gray-600 rounded-lg p-3 text-sm text-gray-300 bg-gray-700 min-h-[60px]">
            <div id="fileList" class="space-y-1.5">
                 <p id="noFilesMessage" class="text-gray-400 italic text-center py-2">No files selected yet.</p>
            </div>
        </div>
    </div>


    <!-- Combine Button -->
    <button id="combineButton" onclick="combineFiles()" class="w-full px-5 py-3 bg-green-600 text-white rounded shadow-md hover:bg-green-700 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-offset-gray-800 focus-visible:ring-green-500 active:bg-green-800 transition-all disabled:opacity-50 disabled:cursor-not-allowed font-semibold mb-4" disabled>
        Combine <span id="fileCount">(0)</span> Files
    </button>

    <!-- Download & Copy Area -->
     <div id="outputArea" class="mt-2 text-center hidden space-y-2 sm:space-y-0 sm:space-x-2 sm:flex sm:justify-center">
        <a id="downloadLink" class="inline-block w-full sm:w-auto px-4 py-2 bg-purple-600 text-white rounded shadow-md hover:bg-purple-700 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-offset-gray-800 focus-visible:ring-purple-500 active:bg-purple-800 transition-all text-sm font-medium truncate max-w-full" download="combined_files.txt">
            <!-- Text content set by JS -->
        </a>
         <button id="copyButton" onclick="copyToClipboard()" class="inline-block w-full sm:w-auto px-4 py-2 bg-indigo-600 text-white rounded shadow-md hover:bg-indigo-700 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-offset-gray-800 focus-visible:ring-indigo-500 active:bg-indigo-800 transition-all text-sm font-medium">
            Copy to Clipboard
        </button>
    </div>
    <p id="copyStatusMessage" class="text-center text-green-400 text-xs mt-2 h-3"></p> <!-- Area for Copy Status -->

</div>

<!-- JSZip Script Loading -->
<script>
    const JSZIP_SOURCES = [
        'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js',
        'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js',
        'jszip.min.js' // Local fallback - Make sure this file exists in the same directory
    ];
    let jszipLoadingPromise = null;
    let jszipLoaded = (typeof JSZip !== 'undefined');

    async function loadJSZipIfNeeded() {
        if (jszipLoaded) return true;
        if (jszipLoadingPromise) return jszipLoadingPromise;

        console.log("Attempting to load JSZip...");
        jszipLoadingPromise = new Promise((resolve, reject) => {
            let attempts = 0;
            const maxAttempts = JSZIP_SOURCES.length;

            function tryLoad() {
                if (attempts >= maxAttempts) {
                    console.error('Failed to load JSZip after trying all sources.');
                    jszipLoadingPromise = null;
                    return reject(new Error('Failed to load JSZip library. Cannot process Zip files.'));
                }

                const source = JSZIP_SOURCES[attempts++];
                console.log(`Trying source ${attempts}: ${source}`);
                const script = document.createElement('script');
                script.src = source;
                script.async = true;

                const timeoutDuration = 5000;
                let timeoutId = setTimeout(() => {
                    console.warn(`Timeout loading JSZip from ${source}`);
                    script.remove();
                    tryLoad();
                }, timeoutDuration);

                script.onload = () => {
                    clearTimeout(timeoutId);
                    if (typeof JSZip !== 'undefined') {
                        console.log(`JSZip loaded successfully from ${source}`);
                        jszipLoaded = true;
                        jszipLoadingPromise = null;
                        resolve(true);
                    } else {
                        console.warn(`JSZip script loaded from ${source}, but JSZip object not found.`);
                        script.remove();
                        tryLoad();
                    }
                };

                script.onerror = (event) => {
                    clearTimeout(timeoutId);
                    // Don't log error for local fallback if it just doesn't exist
                    if (!source.startsWith('http') && attempts === maxAttempts) {
                         console.warn(`Local JSZip file (${source}) not found or failed to load.`);
                    } else {
                         console.warn(`Error loading JSZip from ${source}`, event);
                    }
                    script.remove();
                    tryLoad();
                };

                document.head.appendChild(script);
            }
            tryLoad();
        });
        return jszipLoadingPromise;
    }
</script>

<!-- Main Application Logic -->
<script>
    // Globals
    let selectedFiles = []; // Stores { id, sourceName, sourceZipName?, displayName, content, originalSize }
    let nextFileId = 0;
    let lastCombinedContent = ''; // To store content for the copy button

    // Whitelist of likely text file extensions
    const ALLOWED_EXTENSIONS = new Set([
        'txt', 'js', 'ts', 'jsx', 'tsx', 'css', 'html', 'htm', 'py', 'rb', 'java',
        'c', 'cpp', 'h', 'hpp', 'cs', 'php', 'sql', 'md', 'json', 'xml',
        'yaml', 'yml', 'sh', 'bat', 'ini', 'log', 'svg', 'gitignore', 'env',
        'dockerfile', 'conf', 'config', 'gradle', 'properties', 'toml', 'rst'
    ]);

    // DOM References
    const fileInputEl = document.getElementById('fileInput');
    const fileListContainer = document.getElementById('fileList');
    const noFilesMessageEl = document.getElementById('noFilesMessage');
    const combineButton = document.getElementById('combineButton');
    const clearAllButton = document.getElementById('clearAllButton'); // New button
    const fileCountSpan = document.getElementById('fileCount');
    const outputArea = document.getElementById('outputArea'); // Container for download/copy
    const downloadLink = document.getElementById('downloadLink');
    const copyButton = document.getElementById('copyButton'); // New button
    const copyStatusMessage = document.getElementById('copyStatusMessage'); // Status message element
    const processingZipIndicator = document.getElementById('processingZipIndicator');
    const errorMessageElement = document.getElementById('errorMessage');

    // --- Utility Functions ---
    function clearError() { errorMessageElement.textContent = ''; }
    function displayError(msg, duration = 5000) {
        console.error(msg);
        errorMessageElement.textContent = msg;
        if (duration > 0) { setTimeout(clearError, duration); }
    }
    function getFileExtension(filename) { return filename.slice((filename.lastIndexOf(".") - 1 >>> 0) + 2).toLowerCase(); }
    function isLikelyTextFile(name) { return ALLOWED_EXTENSIONS.has(getFileExtension(name)); }
    function readFileAsText(file) { /* ... (keep existing implementation) ... */
         return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = (e) => reject(new Error(`Error reading ${file.name}: ${e.target.error}`));
            reader.readAsText(file); // Specify encoding if needed, defaults mostly fine
        });
    }
    function getRelativePath(file) { return file.webkitRelativePath || file.name; }
    function formatBytes(bytes, decimals = 2) { /* ... (keep existing implementation) ... */
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

     // --- UI Update Functions ---

    function updateFileListUI() {
        fileListContainer.innerHTML = '';
        if (selectedFiles.length === 0) {
             fileListContainer.appendChild(noFilesMessageEl);
             noFilesMessageEl.classList.remove('hidden');
        } else {
             noFilesMessageEl.classList.add('hidden');
             selectedFiles.forEach(f => {
                const div = document.createElement('div');
                div.className = 'flex justify-between items-center bg-gray-600 px-3 py-1.5 rounded hover:bg-gray-500 transition-colors duration-150 ease-in-out';
                div.setAttribute('role', 'listitem');
                const displayNameSpan = document.createElement('span');
                displayNameSpan.className = 'truncate mr-2 flex-1';
                displayNameSpan.textContent = f.displayName;
                displayNameSpan.title = f.displayName;
                const removeButton = document.createElement('button');
                removeButton.onclick = () => removeFile(f.id);
                removeButton.className = 'ml-2 text-red-400 hover:text-red-300 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-red-400 rounded px-1';
                removeButton.innerHTML = '×';
                removeButton.setAttribute('aria-label', `Remove ${f.displayName}`);
                removeButton.setAttribute('tabindex', '0');
                div.appendChild(displayNameSpan);
                div.appendChild(removeButton);
                fileListContainer.appendChild(div);
            });
        }

        const count = selectedFiles.length;
        combineButton.disabled = count === 0;
        clearAllButton.disabled = count === 0; // Enable/disable Clear All button
        fileCountSpan.textContent = `(${count})`;

        // Hide output area and clear content if file list changes
        outputArea.classList.add('hidden');
        lastCombinedContent = ''; // Clear stored content
        copyStatusMessage.textContent = ''; // Clear copy status
        if (downloadLink.href) {
             URL.revokeObjectURL(downloadLink.href);
             downloadLink.removeAttribute('href');
             downloadLink.textContent = '';
        }
    }

    function removeFile(id) {
        selectedFiles = selectedFiles.filter(f => f.id !== id);
        updateFileListUI();
    }

    // --- New Function: Clear All Files ---
    function clearAllFiles() {
        selectedFiles = [];
        fileInputEl.value = ''; // Also reset file input value if needed
        updateFileListUI();
        clearError(); // Clear any existing errors
    }

    // --- Core Logic ---

    async function addFiles() {
        clearError();
        const files = Array.from(fileInputEl.files || []);
        let processedCount = 0;
        const filesToAdd = [];

        fileInputEl.value = ''; // Reset file input

        for (const file of files) {
            const isZip = file.name.toLowerCase().endsWith('.zip');

            if (isZip) {
                processingZipIndicator.classList.remove('hidden');
                try {
                    await loadJSZipIfNeeded();
                    const zip = await JSZip.loadAsync(file);
                    const zipEntries = Object.entries(zip.files);

                    for (const [relativePath, entry] of zipEntries) {
                        if (!entry.dir && isLikelyTextFile(relativePath)) {
                            try {
                                const content = await entry.async('string');
                                filesToAdd.push({
                                    id: nextFileId++, sourceName: file.name, sourceZipName: file.name,
                                    displayName: `${file.name} > ${relativePath}`, content: content, originalSize: content.length
                                });
                                processedCount++;
                            } catch (readError) { displayError(`Error reading ${relativePath} from ${file.name}: ${readError.message}`, 0); }
                        } else if (!entry.dir) { console.log(`Skipping non-text file in zip: ${relativePath}`); }
                    }
                } catch (zipError) { displayError(`Error processing ${file.name}: ${zipError.message}`, 0); }
                 finally { /* We hide indicator after all files processed */ }
            } else if (isLikelyTextFile(file.name)) {
                try {
                    const content = await readFileAsText(file);
                    filesToAdd.push({
                        id: nextFileId++, sourceName: file.name, displayName: getRelativePath(file),
                        content: content, originalSize: file.size
                    });
                    processedCount++;
                } catch (readError) { displayError(readError.message, 0); }
            } else { console.log(`Skipping unsupported file type: ${file.name}`); }
        }

        processingZipIndicator.classList.add('hidden');

        if (filesToAdd.length > 0) {
            selectedFiles.push(...filesToAdd);
            selectedFiles.sort((a, b) => a.displayName.localeCompare(b.displayName));
            updateFileListUI();
        }

        if (processedCount === 0 && files.length > 0) {
             displayError(`No text files found or processed from the selection.`, 5000);
        }
    }

    // --- Structure Generation Functions ---
    // (Keep existing generateTreeStructure, generateFlatStructure, etc. functions)
    function buildFileTree(files) { /* ... (keep existing implementation) ... */
        const tree = {};
        files.forEach(f => {
            const pathParts = f.displayName.split(' > ');
            const sourceKey = pathParts[0];
            const relativePath = pathParts.slice(1).join('/');
            if (!tree[sourceKey]) { tree[sourceKey] = { files: [], folders: {} }; }
            const segments = relativePath.split('/').filter(Boolean);
            let currentLevel = tree[sourceKey];
            segments.forEach((segment, index) => {
                if (index === segments.length - 1) {
                    currentLevel.files.push(segment); currentLevel.files.sort();
                } else {
                    if (!currentLevel.folders[segment]) { currentLevel.folders[segment] = { files: [], folders: {} }; }
                    currentLevel = currentLevel.folders[segment];
                }
            });
        }); return tree;
    }
    function renderTreeSimple(node, depth = 0) { /* ... (keep existing implementation) ... */
        let output = ''; const indent = '  '.repeat(depth);
        const folderKeys = Object.keys(node.folders).sort(); const files = node.files.sort();
        folderKeys.forEach(key => { output += `${indent}- ${key}/\n`; output += renderTreeSimple(node.folders[key], depth + 1); });
        files.forEach(file => { output += `${indent}- ${file}\n`; }); return output;
    }
    function generateTreeStructure(files) { /* ... (keep existing implementation) ... */
        const fileTree = buildFileTree(files); let output = "/* ==== File Structure (Tree) ==== */\n";
        const sourceKeys = Object.keys(fileTree).sort();
        sourceKeys.forEach(sourceKey => {
            const isSingleSourceNonZip = sourceKeys.length === 1 && !sourceKey.toLowerCase().endsWith('.zip');
            if (!isSingleSourceNonZip) { output += `${sourceKey}:\n`; }
            output += renderTreeSimple(fileTree[sourceKey], isSingleSourceNonZip ? 0 : 1); output += "\n";
        }); output += "/* =============================== */\n"; return output.replace(/\n\n$/, '\n');
    }
    function generateFlatStructure(files) { /* ... (keep existing implementation) ... */
        const filePaths = files.map(f => {
            const pathParts = f.displayName.split(' > ');
            if (files.some(other => other.sourceZipName) || new Set(files.map(fl => fl.sourceName)).size > 1) { return f.displayName; }
            else { return pathParts.slice(pathParts.length > 1 ? 1 : 0).join('/'); }
        }).sort();
        return "/* ==== File List (Flat) ==== */\n" + filePaths.join('\n') + "\n/* ========================== */\n";
    }
    function generateSimpleListStructure(files) { /* ... (keep existing implementation) ... */
         const filePaths = files.map(f => {
            const pathParts = f.displayName.split(' > ');
             if (files.some(other => other.sourceZipName) || new Set(files.map(fl => fl.sourceName)).size > 1) { return f.displayName; }
             else { return pathParts.slice(pathParts.length > 1 ? 1 : 0).join('/'); }
        }).sort();
        return "/* ==== File List (Numbered) ==== */\n" +
            filePaths.map((path, i) => `${i + 1}. ${path}`).join('\n') + "\n/* ============================ */\n";
    }
    function generateDetailedStructure(files) { /* ... (keep existing implementation) ... */
        const totalBytes = files.reduce((sum, f) => sum + (f.originalSize || 0), 0);
        const fileLines = files.map(f => {
             const pathParts = f.displayName.split(' > '); let displayPath;
             if (files.some(other => other.sourceZipName) || new Set(files.map(fl => fl.sourceName)).size > 1) { displayPath = f.displayName; }
             else { displayPath = pathParts.slice(pathParts.length > 1 ? 1 : 0).join('/'); }
            const size = formatBytes(f.originalSize || 0); return `- ${displayPath} (${size})`;
        }).sort();
        return `/* ==== Detailed Summary ====
Date: ${new Date().toISOString()}
Total Files: ${files.length}
Total Size: ${formatBytes(totalBytes)}

Files:
${fileLines.join('\n')}
*/\n`;
    }
    function generateMarkdownStructure(files) { /* ... (keep existing implementation) ... */
        let md = "# File Structure\n\n"; const groups = {};
        let hasMultipleSources = new Set(files.map(f => f.sourceName)).size > 1 || files.some(f => f.sourceZipName);
        files.forEach(f => {
            const pathParts = f.displayName.split(' > '); const sourceKey = pathParts[0]; const relativePath = pathParts.slice(1).join('/');
            const key = hasMultipleSources ? sourceKey : 'Files';
            if (!groups[key]) groups[key] = []; groups[key].push(relativePath || sourceKey);
        });
        const sortedKeys = Object.keys(groups).sort();
        sortedKeys.forEach(key => {
            if (hasMultipleSources) { md += `## ${key}\n\n`; }
            const sortedPaths = groups[key].sort(); sortedPaths.forEach(path => md += `- \`${path}\`\n`); md += '\n';
        }); return md;
    }


    // --- Combine and Download ---

    function combineFiles() {
        clearError();
        copyStatusMessage.textContent = ''; // Clear previous copy status
        if (selectedFiles.length === 0) {
            displayError("No files selected to combine.", 3000);
            return;
        }

        const structureFormat = document.getElementById('structureFormat').value;
        const disableComments = document.getElementById('disableCommentsCheckbox').checked; // Checkbox state
        let header = '';

        try {
            // Generate structure header only if comments are NOT disabled
            if (!disableComments) {
                 switch (structureFormat) {
                    case 'tree':     header = generateTreeStructure(selectedFiles); break;
                    case 'flat':     header = generateFlatStructure(selectedFiles); break;
                    case 'simple':   header = generateSimpleListStructure(selectedFiles); break;
                    case 'detailed': header = generateDetailedStructure(selectedFiles); break;
                    case 'markdown': header = generateMarkdownStructure(selectedFiles); break;
                    case 'none':     header = ''; break;
                }
            } else if (structureFormat === 'detailed') {
                 // Special case: Keep detailed summary even if comments disabled? Or make it optional?
                 // Let's keep it simple: disable header means disable header.
                 header = '';
            }
        } catch (e) {
             displayError(`Error generating file structure: ${e.message}`, 0);
             console.error("Structure generation error:", e);
             return;
        }

        const startTemplate = document.getElementById('startComment').value;
        const endTemplate = document.getElementById('endComment').value;
        let combinedContent = header + (header ? '\n' : ''); // Add newline only if header exists
        const totalFiles = selectedFiles.length;

        selectedFiles.forEach((file, index) => {
             const fileIndex = index + 1; // 1-based index
             const pathParts = file.displayName.split(' > ');
             const path = pathParts.slice(1).join('/') || file.sourceName;
             const filename = path.split('/').pop();

             if (!disableComments) {
                 const startComment = startTemplate
                    .replace(/\{filename\}/g, filename)
                    .replace(/\{path\}/g, path)
                    .replace(/\{index\}/g, fileIndex)
                    .replace(/\{totalFiles\}/g, totalFiles);
                 combinedContent += startComment + '\n';
             }

             combinedContent += file.content.trim() + '\n'; // Add trimmed content + newline

             if (!disableComments) {
                 const endComment = endTemplate
                     .replace(/\{filename\}/g, filename)
                     .replace(/\{path\}/g, path)
                     .replace(/\{index\}/g, fileIndex)
                     .replace(/\{totalFiles\}/g, totalFiles);
                 combinedContent += endComment + '\n\n'; // Two newlines after end comment
             } else {
                 combinedContent += '\n'; // Add one newline for separation if comments are disabled
             }
        });

        // Remove the very last extra newline added by the loop
        combinedContent = combinedContent.trimEnd() + '\n';

        lastCombinedContent = combinedContent; // Store for copy button

        // Determine filename
        let downloadFilename;
        let singleZipSourceName = null;
        let allFromSameZip = selectedFiles.length > 0;
        if (allFromSameZip) { /* ... (keep existing filename logic) ... */
            singleZipSourceName = selectedFiles[0].sourceZipName;
            if (!singleZipSourceName) { allFromSameZip = false; }
            else {
                for (let i = 1; i < selectedFiles.length; i++) {
                    if (selectedFiles[i].sourceZipName !== singleZipSourceName) { allFromSameZip = false; break; }
                }
            }
        } else { allFromSameZip = false; }

        if (allFromSameZip && singleZipSourceName) {
            const zipBaseName = singleZipSourceName.replace(/\.zip$/i, '');
            downloadFilename = `${zipBaseName} - Combined.txt`;
        } else {
            const dateStamp = new Date().toISOString().split('T')[0];
            downloadFilename = `combined_files_${dateStamp}.txt`;
        }

        // Create Blob and Download Link
        try {
            const blob = new Blob([combinedContent], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            if (downloadLink.href) { URL.revokeObjectURL(downloadLink.href); }
            downloadLink.href = url;
            downloadLink.download = downloadFilename;
            downloadLink.textContent = `Download ${downloadFilename}`;
            outputArea.classList.remove('hidden'); // Show output area (download + copy buttons)

        } catch (e) {
             displayError(`Error creating download file: ${e.message}`, 0);
             console.error("Blob creation error:", e);
             outputArea.classList.add('hidden');
             lastCombinedContent = ''; // Clear content if blob fails
        }
    }

    // --- New Function: Copy to Clipboard ---
    async function copyToClipboard() {
        copyStatusMessage.textContent = ''; // Clear previous message
        if (!lastCombinedContent) {
            displayError("No content generated to copy.", 3000);
            return;
        }
        if (!navigator.clipboard) {
            displayError("Clipboard API not available in this browser.", 5000);
            return;
        }

        try {
            await navigator.clipboard.writeText(lastCombinedContent);
            copyStatusMessage.textContent = 'Copied to clipboard!';
            // Optionally clear the message after a few seconds
            setTimeout(() => { copyStatusMessage.textContent = ''; }, 3000);
        } catch (err) {
            displayError(`Failed to copy: ${err}`, 5000);
            console.error('Clipboard write failed: ', err);
        }
    }


    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
         updateFileListUI(); // Initial UI state
         if (!jszipLoaded) {
            loadJSZipIfNeeded().catch(err => {
                 console.warn("Preloading JSZip failed (might load on demand):", err.message);
            });
         }
    });

</script>

</body>
</html>